<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bi-saturation · spin</title><meta name="title" content="Bi-saturation · spin"/><meta property="og:title" content="Bi-saturation · spin"/><meta property="twitter:title" content="Bi-saturation · spin"/><meta name="description" content="Documentation for spin."/><meta property="og:description" content="Documentation for spin."/><meta property="twitter:description" content="Documentation for spin."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">spin</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="tir_saturation.html">Bi-saturation</a><ul class="internal"><li><a class="tocitem" href="#Direct-Method-:"><span>Direct Method :</span></a></li><li><a class="tocitem" href="#Indirect-Method-:"><span>Indirect Method :</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tir_saturation.html">Bi-saturation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tir_saturation.html">Bi-saturation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/spin" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/spin/blob/main/docs/src/tir_saturation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Saturation-of-pair-of-spins-:-direct-and-indirect-solutions"><a class="docs-heading-anchor" href="#Saturation-of-pair-of-spins-:-direct-and-indirect-solutions">Saturation of pair of spins : direct and indirect solutions</a><a id="Saturation-of-pair-of-spins-:-direct-and-indirect-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Saturation-of-pair-of-spins-:-direct-and-indirect-solutions" title="Permalink"></a></h1><p>Previously, we attempted to solve the bi-saturation problem as mentioned in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> using a direct method. We will now proceed to solve the same problem using an indirect method.</p><p>In this analysis, we will use the solution obtained from the direct method as an integral component of the shooting method. By leveraging the direct method&#39;s results, we aim to enhance the accuracy and efficiency of the shooting method&#39;s implementation.</p><h2 id="Direct-Method-:"><a class="docs-heading-anchor" href="#Direct-Method-:">Direct Method :</a><a id="Direct-Method-:-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Method-:" title="Permalink"></a></h2><p>Let&#39;s first import the necessary packages, <em>OptimalControl</em>, <em>Plots</em> ... : </p><pre><code class="language-julia hljs">using OrdinaryDiffEq
using LinearAlgebra: norm
using MINPACK
using OptimalControl
using Plots
using NLPModelsIpopt</code></pre><p>We will now define the parameters and the functions that we will use later on : </p><pre><code class="language-julia hljs"># Define the parameters of the problem and the starting point
Γ = 9.855e-2
γ = 3.65e-3
ϵ = 0.1
q0 = [0, 1, 0, 1]

@def ocp1 begin
    tf ∈ R, variable
    t ∈ [0, tf], time
    x ∈ R⁴, state
    u ∈ R, control
    tf ≥ 0
    -1 ≤ u(t) ≤ 1
    x(0) == [0, 1, 0, 1]
    x(tf) == [0, 0, 0, 0]

    ẋ(t) == [(-Γ*x₁(t) -u(t)*x₂(t)),
             (γ*(1-x₂(t)) +u(t)*x₁(t)),
             (-Γ*x₃(t) -(1-ϵ)* u(t)*x₄(t)),
             (γ*(1-x₄(t)) +(1-ϵ)*u(t)*x₃(t))]
    tf → min
end

@def ocp2 begin
    tf ∈ R, variable
    t ∈ [0, tf], time
    x ∈ R⁴, state
    u ∈ R, control
    tf ≥ 0
    -1 ≤ u(t) ≤ 1
    x(0) == [0.1, 0.9, 0.1, 0.9]
    x(tf) == [0, 0, 0, 0]

    ẋ(t) == [(-Γ*x₁(t) -u(t)*x₂(t)),
             (γ*(1-x₂(t)) +u(t)*x₁(t)),
             (-Γ*x₃(t) -(1-ϵ)* u(t)*x₄(t)),
             (γ*(1-x₄(t)) +(1-ϵ)*u(t)*x₃(t))]
    tf → min
end
# Function to plot the solution of the optimal control problem
function plot_sol(sol)
    q = sol.state
    liste = [q(t) for t in sol.times]
    liste_y1 = [elt[1] for elt in liste]
    liste_z1 = [elt[2] for elt in liste]
    liste_y2 = [elt[3] for elt in liste]
    liste_z2 = [elt[4] for elt in liste]
    plot(
        plot(liste_y1, liste_z1, xlabel=&quot;y1&quot;, ylabel=&quot;z1&quot;),
        plot(liste_y2, liste_z2, xlabel=&quot;y2&quot;, ylabel=&quot;z2&quot;),
        plot(sol.times, sol.control, xlabel=&quot;Time&quot;, ylabel=&quot;Control&quot;)
    )
end


function F0i(q)
    y, z = q
    res = [-Γ*y, γ*(1-z)]
    return res
end

function F1i(q)
    y, z = q
    res = [-z, y]
    return res
end

F0(q) = [ F0i(q[1:2]); F0i(q[3:4]) ]
F1(q) = [ F1i(q[1:2]); (1 - ϵ) * F1i(q[3:4]) ]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">F1 (generic function with 1 method)</code></pre><p>We will use the same technique used before to solve the problem which involves using the solution of the same problem but with a slight change in the initial conditions, as an initial guess. </p><pre><code class="language-julia hljs">initial_g = solve(ocp2; grid_size=1000, linear_solver=&quot;mumps&quot;)
direct_sol = solve(ocp1; grid_size=1000, init=initial_g, linear_solver=&quot;mumps&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CTBase.OptimalControlSolution</code></pre><p>We will now plot the solution : </p><pre><code class="language-julia hljs">plt = plot(direct_sol, solution_label=&quot;(direct)&quot;)</code></pre><img src="tir_saturation-34693039.svg" alt="Example block output"/><h2 id="Indirect-Method-:"><a class="docs-heading-anchor" href="#Indirect-Method-:">Indirect Method :</a><a id="Indirect-Method-:-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-Method-:" title="Permalink"></a></h2><p>A quick look on the plot of the control u, reveals that the optimal solution consists of a bang arc with minimal control(-1), followed by a singular arc, then another bang arc with maximal control (+1), and the final arc is a singular arc, which means that <strong>we have a solution with a structure of the form BSBS, i.e. Bang-Singular-Bang-Singular</strong> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  First, let&#39;s define the Hamiltonian operator. Since : </p><p class="math-container">\[\dot q = F_0(q) + u * F_1(q)\]</p><p>then : </p><p class="math-container">\[H(q,p) = p&#39; * F_0(q) + u * p&#39; * F_1(q)\]</p><p>We&#39;ll note : <span>$H_0(q,p) = p&#39; * F_0(q) $ and $H_1(q,p) = p&#39; * F_1(q)$</span> Let <span>$u_{+} = 1$</span>, the positive bang control (resp. <span>$u_{-} = -1$</span> the negative bang control),  and </p><p class="math-container">\[u_s(q,p) = - \frac{H_{001}}{H_{101}} \]</p><p>the singular control, where : <span>$H_{001} ​= \{H_0 ​, \{H_0​, H_1\​}\}, H_{101} ​= \{H_1​, \{H_0​, H_1\​}\}$</span> and for two Hamiltonien operators <span>$H_0​, H_1$</span> :  </p><p class="math-container">\[\{H_0, H_1\} :=({\nabla}_p H_0  ∣ {\nabla}_x H_1 ) − ({\nabla}_x H_0 ∣ {\nabla}_p H_1)\]</p><p>First, we refine the solution with a higher grid size for better accuracy. We also lift the vector fields to their Hamiltonian counterparts and compute the Lie brackets of these Hamiltonian vector fields. Additionally, we define the singular control function and extract the solution components.</p><pre><code class="language-julia hljs"># Lift the vector fields to their Hamiltonian counterparts
H0 = Lift(F0)
H1 = Lift(F1)

# Compute the Lie brackets of the Hamiltonian vector fields
H01  = @Lie { H0, H1 }
H001 = @Lie { H0, H01 }
H101 = @Lie { H1, H01 }

# Define the singular control function
us(q, p) = -H001(q, p) / H101(q, p)

#~Define the maximum control
umax = 1

# Extract the solution components
t = direct_sol.times
q = direct_sol.state
u = direct_sol.control
p = direct_sol.costate

# Define the flows for maximum, minimum, and singular controls
fₚ = Flow(ocp1, (q, p, tf) -&gt; umax)
fₘ = Flow(ocp1, (q, p, tf) -&gt; -umax)
fs = Flow(ocp1, (q, p, tf) -&gt; us(q, p))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CTFlowsODE.OptimalControlFlow{CTBase.NonFixed}(CTFlowsODE.var&quot;#f#38&quot;{CTFlowsODE.var&quot;#f#36#39&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Float64, Float64, Vector{Any}}}(CTFlowsODE.var&quot;#f#36#39&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Float64, Float64, Vector{Any}}(Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}(), Tsit5(; stage_limiter! = trivial_limiter!, step_limiter! = trivial_limiter!, thread = static(false),), 1.0e-10, 1.0e-10, Any[]), Core.Box(CTFlowsODE.var&quot;#f#37#40&quot;(Core.Box(CTFlowsODE.var&quot;#f#38&quot;{CTFlowsODE.var&quot;#f#36#39&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, Float64, Float64, Vector{Any}}}(#= circular reference @-4 =#))))), CTFlowsODE.var&quot;#rhs!#41&quot;{CTBase.Hamiltonian{CTBase.NonAutonomous, CTBase.NonFixed}}(CTBase.Hamiltonian{CTBase.NonAutonomous, CTBase.NonFixed}(CTFlows.var&quot;#18#19&quot;{CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}, CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}}(CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;##241#1&quot;()), CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;#19#20&quot;())))), Real[], Tuple{Real, Union{Real, AbstractVector{&lt;:Real}}}[], CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;#19#20&quot;()), CTBase.OptimalControlModel{CTBase.Autonomous, CTBase.NonFixed}
  model_expression: Expr
  initial_time: Int64 0
  initial_time_name: String &quot;0&quot;
  final_time: CTBase.Index
  final_time_name: String &quot;tf&quot;
  time_name: String &quot;t&quot;
  control_dimension: Int64 1
  control_components_names: Array{String}((1,))
  control_name: String &quot;u&quot;
  state_dimension: Int64 4
  state_components_names: Array{String}((4,))
  state_name: String &quot;x&quot;
  variable_dimension: Int64 1
  variable_components_names: Array{String}((1,))
  variable_name: String &quot;tf&quot;
  lagrange: Nothing nothing
  mayer: CTBase.Mayer{CTBase.NonFixed}
  criterion: Symbol min
  dynamics: CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}
  constraints: Dict{Symbol, Tuple}
  dim_control_constraints: Int64 0
  dim_state_constraints: Int64 0
  dim_mixed_constraints: Int64 0
  dim_boundary_constraints: Int64 8
  dim_variable_constraints: Int64 0
  dim_control_range: Int64 1
  dim_state_range: Int64 0
  dim_variable_range: Int64 1
, (alg = Tsit5(; stage_limiter! = trivial_limiter!, step_limiter! = trivial_limiter!, thread = static(false),), abstol = 1.0e-10, reltol = 1.0e-10, saveat = Any[]))</code></pre><p>Next, we define a function to compute the shooting function for the indirect method. This function calculates the state and costate at the switching times and populates the shooting function residuals based on its expression :</p><p class="math-container">\[S : \mathbb{R}^{32} \rightarrow \mathbb{R}^{32}\]</p><p class="math-container">\[y =
\begin{bmatrix}
p_0 \\
t_f \\
t_1 \\
t_2 \\
t_3 \\
z_1 \\
z_2 \\
z_3
\end{bmatrix}
\mapsto S(y) :=
\begin{bmatrix}
u \pm H_1(z_0) + p_0 \\
H_1(z_1) \\
H&#39;_1(z_1) \\
H_1(z_3) \\
H&#39;_1(z_3) \\
y_2(t_f, t_3, z_3, u_s) \\
z_2(t_f, t_3, z_3, u_s) \\
(p_{z_1}(t_f, t_3, z_3, u_s) + p_{z_2}(t_f, t_3, z_3, u_s)) \gamma + p_0 \\
z(t_1, 0, z_0, u \pm) - z_1 \\
z(t_2, t_1, z_1, u_s) - z_2 \\
z(t_3, t_2, z_2, u \pm) - z_3
\end{bmatrix}\]</p><pre><code class="language-julia hljs"># Function to compute the shooting function for the indirect method
function shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
    qi1, pi1 = fₘ(0, q0, p0, t1)
    qi2, pi2 = fs(t1, q1, p1, t2)
    qi3, pi3 = fₚ(t2, q2, p2, t3)
    qf, pf = fs(t3, q3, p3, tf)
    s[1] = H0(q0, p0) - umax * H1(q0, p0) - 1
    s[2] = H1(q1, p1)
    s[3] = H01(q1, p1)
    s[4] = H1(q3, p3)
    s[5] = H01(q3, p3)
    s[6] = qf[3]
    s[7] = qf[4]
    s[8] = (pf[2] + pf[4]) * γ - 1
    s[9:12] = qi1 - q1
    s[13:16] = pi1 - p1
    s[17:20] = qi2 - q2
    s[21:24] = pi2 - p2
    s[25:28] = qi3 - q3
    s[29:32] = pi3 - p3
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">shoot! (generic function with 1 method)</code></pre><p>We then initialize parameters to find the switching times. We identify the intervals where the control is near zero, indicating singular control, and determine the switching times.</p><pre><code class="language-julia hljs"># Initialize parameters for finding switching times
t0 = 0
tol = 2e-2

# Find times where control is near zero (singular control)
t13 = [elt for elt in t if abs(u(elt)) &lt; tol]
i = 1
t_l = []

# Identify intervals for switching times
while(true)
    global i
    if (( i == length(t13)-1) || (t13[i+1] - t13[i] &gt; 1) )
        break
    else
        push!(t_l, t13[i])
        push!(t_l, t13[i+1])
        i += 1
    end
end

# Determine the switching times
t1 = min(t_l...)
t2 = max(t_l...)
t3f = [elt for elt in t13 if elt &gt; t2]
t3 = min(t3f...)

# Extract initial and intermediate costates and states and final time
p0 = p(t0)

tf = direct_sol.objective
q1, p1 = q(t1), p(t1)
q2, p2 = q(t2), p(t2)
q3, p3 = q(t3), p(t3)
δ = γ - Γ
zs = γ/(2*δ)

q1[2] = zs
p1[2] = p1[1] * (zs / q1[1])
q1[4] = zs
p1[4] = p1[3] *(zs / q1[3])
p0[1] = -1
p0[3] = -1
println(&quot;p0 = &quot;, p0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)
println(&quot;p1 = &quot;, p1)
println(&quot;p2 = &quot;, p2)
println(&quot;p3 = &quot;, p3)
println(&quot;q1 = &quot;, q1)
println(&quot;q2 = &quot;, q2)
println(&quot;q3 = &quot;, q3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">p0 = [-1.0, -2.7088792537289126, -1.0, -7.161025073587199]
t1 = 1.8355505720665606
t2 = 9.580678595664486
t3 = 13.117471161353711
tf = 44.76952614796489
p1 = [-3.221834165852605, 0.06921606163647585, -7.978635714250412, 0.1680727863450961]
p2 = [-7.009088108054607, -1.2229297889644637, -16.984887719583906, 2.4305607520921586]
p3 = [7.575108189527492, 4.157061415625297, 20.362702631187013, -3.0729729225183617]
q1 = [0.8951441020832105, -0.019230769230769232, 0.9129098501531455, -0.019230769230769232]
q2 = [0.41239916325356496, -0.13205099925091726, 0.4266061321070234, 0.03252300248875061]
q3 = [-0.3616387591566783, -0.009700296760401433, -0.36304130300292153, -0.023441270241164488]</code></pre><p>Next, we initialize the shooting function residuals and compute the initial residuals for the shooting function to verify the solution&#39;s accuracy. </p><pre><code class="language-julia hljs"># Initialize the shooting function residuals
s = similar(p0, 32)

# Compute the initial residuals for the shooting function
shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Norm of the shooting function: ‖s‖ = 4.752588384929972</code></pre><p>The direct solution is not very accurate, as shown by the shooting function&#39;s value of about <span>$1.11$</span> using the parameters from the direct method.</p><p>We now define a nonlinear equation solver for the shooting method. This solver refines the initial costate, switching times and the intermediate states and costates to find the optimal solution using the shooting function.</p><pre><code class="language-julia hljs"># Define a nonlinear equation solver for the shooting method
nle = (s, ξ) -&gt; shoot!(s, ξ[1:4], ξ[5], ξ[6], ξ[7], ξ[8], ξ[9:12], ξ[13:16], ξ[17:20], ξ[21:24], ξ[25:28], ξ[29:32])
ξ = [ p0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3 ]
# Solve the shooting equations to find the optimal times and costate

indirect_sol = fsolve(nle, ξ; tol=5e-3, show_trace=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Results of Nonlinear Solver Algorithm
 * Algorithm: Modified Powell
 * Starting Point: [-1.0, -2.7088792537289126, -1.0, -7.161025073587199, 1.8355505720665606, 9.580678595664486, 13.117471161353711, 44.76952614796489, 0.8951441020832105, -0.019230769230769232, 0.9129098501531455, -0.019230769230769232, -3.221834165852605, 0.06921606163647585, -7.978635714250412, 0.1680727863450961, 0.41239916325356496, -0.13205099925091726, 0.4266061321070234, 0.03252300248875061, -7.009088108054607, -1.2229297889644637, -16.984887719583906, 2.4305607520921586, -0.3616387591566783, -0.009700296760401433, -0.36304130300292153, -0.023441270241164488, 7.575108189527492, 4.157061415625297, 20.362702631187013, -3.0729729225183617]
 * Zero: [2.0037003926872656, -2.71081207842811, -1.1152226586221123, -7.13893500036974, 1.7710636154695123, 9.595572671909736, 13.079739881530207, 44.7673220882882, 0.9007249935478339, -0.13370888065484166, 0.9184658472701844, 0.03322466347084552, -3.242653526687057, -1.4301485544792174, -7.863178635274069, 1.798435558766139, 0.4117252400165162, -0.13127894440300633, 0.4258922166254675, 0.03323355840384848, -7.108627660568242, -1.2086754109147284, -16.869214110416163, 2.4166618656704175, -0.36268897979313647, -0.009606988080895785, -0.3643339500192548, -0.02330531283050013, 7.665160535450455, 4.164603583361683, 20.115192047349492, -3.095157426277101]
 * Inf-norm of residuals: 0.000225
 * Convergence: true
 * Message: algorithm estimates that the relative error between x and the solution is at most tol
 * Total time: 61.156776 seconds
 * Function Calls: 17
 * Jacobian Calls (df/dx): 4</code></pre><p>We extract the initial costate, switching times and the intermediate states and costates. We then recompute the residuals for the shooting function to ensure the accuracy of the refined solution. Therefore, we conclude that this solution is more accurate, as the norm of <em>s</em> in this case is <span>$10^6$</span> smaller than the previously computed one using the direct method.</p><pre><code class="language-julia hljs"># Extract the refined initial costate and switching times from the solution
p0 = indirect_sol.x[1:4]
t1 = indirect_sol.x[5]
t2 = indirect_sol.x[6]
t3 = indirect_sol.x[7]
tf = indirect_sol.x[8]
q1, p1, q2, p2, q3, p3 = indirect_sol.x[9:12], indirect_sol.x[13:16], indirect_sol.x[17:20], indirect_sol.x[21:24], indirect_sol.x[25:28], indirect_sol.x[29:32]

# Recompute the residuals for the shooting function
s = similar(p0, 32)
shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Norm of the shooting function: ‖s‖ = 0.00031685347898032727</code></pre><p>Finally, we define the composed flow solution using the switching times and controls. We compute the flow solution over the time interval and plot both the direct and indirect solutions for comparison.</p><pre><code class="language-julia hljs"># Define the composed flow solution using the switching times and controls
f_sol = fₘ * (t1, fs) * (t2, fₚ) * (t3, fs)

# Compute the flow solution over the time interval
flow_sol = f_sol((t0, tf), q0, p0)

# Plot the direct and indirect solutions for comparison

plot(plt, flow_sol, solution_label=&quot;(indirect)&quot;)</code></pre><img src="tir_saturation-98e75ee4.svg" alt="Example block output"/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Bernard Bonnard, Olivier Cots, Jérémy Rouot, Thibaut Verron. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 20 August 2024 14:17">Tuesday 20 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
